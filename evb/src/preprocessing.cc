/**
 * @file preprocessing.cc
 * @author Adam Page (adam.page@ambiq.com)
 * @brief Perform preprocessing of sensor data (standardize and bandpass filter)
 * @version 1.0
 * @date 2023-03-27
 *
 * @copyright Copyright (c) 2023
 *
 */
#include "preprocessing.h"
#include "arm_math.h"

// AUTOGENERATED: print(hk.datasets.preprocess.generate_arm_biquad_sos(0.5, 30, 250, order=3))
#define BIQUADFILTER_NUM_SECS (3)
static float32_t biquadFilterState[2 * BIQUADFILTER_NUM_SECS];
static float32_t biquadFilter[5 * BIQUADFILTER_NUM_SECS] = {0.027461107467472153,
                                                            0.054922214934944306,
                                                            0.027461107467472153,
                                                            1.0997280329991979,
                                                            -0.5012977494269584,
                                                            1.0,
                                                            0.0,
                                                            -1.0,
                                                            1.433070925390203,
                                                            -0.44021887101067064,
                                                            1.0,
                                                            -2.0,
                                                            1.0,
                                                            1.9875591985256609,
                                                            -0.987718549527938};

arm_biquad_cascade_df2T_instance_f32 iirInst;

uint32_t
init_preprocess() {
    /**
     * @brief Initialize preprocessing block
     *
     */
    arm_biquad_cascade_df2T_init_f32(&iirInst, BIQUADFILTER_NUM_SECS, biquadFilter, biquadFilterState);
    return 0;
}

uint32_t
bandpass_filter(float32_t *pSrc, float32_t *pResult, uint32_t blockSize) {
    /**
     * @brief Perform bandpass filter (0.5-40 Hz) on signal
     */
    arm_biquad_cascade_df2T_f32(&iirInst, pSrc, pResult, blockSize);
    return 0;
}

uint32_t
standardize(float32_t *pSrc, float32_t *pResult, uint32_t blockSize) {
    /**
     * @brief Standardize input y = (x - mu) / std. Provides safegaurd against small st devs
     *
     */
    float32_t mu, std;
    float32_t epsilon = 1e-3;
    arm_mean_f32(pSrc, blockSize, &mu);
    arm_std_f32(pSrc, blockSize, &std);
    std = std + epsilon;
    arm_offset_f32(pSrc, -mu, pResult, blockSize);
    arm_scale_f32(pResult, 1.0f / std, pResult, blockSize);
    return 0;
}

uint32_t
resample_signal(float32_t *pSrc, float32_t *pResult, uint32_t blockSize, uint32_t upSample, uint32_t downSample) {
    /**
     * @brief Resampling signal by upsampling followed by downsamping
     *
     */
    return 1;
}

uint32_t
linear_downsample(float32_t *pSrc, uint32_t srcSize, uint32_t srcFs, float32_t *pRst, uint32_t rstSize, uint32_t rstFs) {
    /**
     * @brief Basic downsampling using linear interpolation
     *
     */
    float32_t ratio = ((float32_t)srcFs) / rstFs;
    for (size_t i = 0; i < rstSize; i++) {
        float32_t xi = i * ratio;
        uint32_t xl = floorf(xi);
        uint32_t xr = ceilf(xi);
        float32_t yl = pSrc[xl];
        float32_t yr = pSrc[xr];
        pRst[i] = xl == xr ? yl : yl + (xi - xl) * ((yr - yl) / (xr - xl));
    }
    return 0;
}
